import 'dart:convert';import 'package:web_socket_channel/web_socket_channel.dart';typedef GameStateCallback = void Function(Map<String, dynamic>);class GameWebSocketHandler {  final String url;  final int currentPlayerId;  final GameStateCallback onGameStateUpdate;  final void Function()? onConnected;  late WebSocketChannel channel;  bool isConnected = false;  final void Function(String gameId)? onMatchFound;  GameWebSocketHandler({    required this.url,    required this.currentPlayerId,    required this.onGameStateUpdate,    required this.onConnected,    this.onMatchFound,  });  void connect() {    channel = WebSocketChannel.connect(Uri.parse(url));    isConnected = true;    print('‚úÖ Connected to WebSocket server');    onConnected?.call();    _listenToMessages();    sendStartMatchmaking();  }  void disconnect() {    isConnected = false;    channel.sink.close();    print('üö™ WebSocket closed');  }  void _listenToMessages() {    channel.stream.listen(          (message) {        try {          final response = jsonDecode(message);          if (response.containsKey('gameId') && onMatchFound != null) {            final gameId = response['gameId'];            onMatchFound!(gameId);          }          onGameStateUpdate(response);        } catch (e) {          print('‚ùå Error deserializing message: $e');        }      },      onDone: () {        print('üö™ WebSocket closed by server');      },      onError: (error) {        print('‚ö†Ô∏è WebSocket error: $error');      },    );  }  void sendMessage(Map<String, dynamic> message) {    if (isConnected) {      final json = jsonEncode(message);      channel.sink.add(json);      print('üì§ Message sent: $json');    }  }  void sendStartMatchmaking() {    final message = {      'action': 'START',      'playerDto': {        'id': currentPlayerId,        'username': 'player$currentPlayerId',      },    };    sendMessage(message);  }  void sendCardToMana({    required String? gameId,    required int playerId,    required String triggeredGameCardId,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'action': 'SEND_CARD_TO_MANA',      'triggeredGameCardId': triggeredGameCardId,    });  }  void summonWithMana({    required String? gameId,    required int playerId,    required String triggeredGameCardId,    required List<String> selectedManaCardIds,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'action': 'SUMMON_TO_BATTLE_ZONE',      'triggeredGameCardId': triggeredGameCardId,      'triggeredGameCardIds': selectedManaCardIds,    });  }  void endTurn({    required String? gameId,    required int playerId,    required int opponentId,    required int? currentTurnPlayerId,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'opponentId': opponentId,      'currentTurnPlayerId': currentTurnPlayerId,      'action': 'END_TURN',    });  }  void attackShieldOrCreature({    required String? gameId,    required int playerId,    required int? currentTurnPlayerId,    required String attackerId,    required String targetId,    required bool? targetShield,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'currentTurnPlayerId': currentTurnPlayerId,      'action': 'ATTACK',      'attackerId': attackerId,      'targetId': targetId,      'shieldTriggersFlagsDto': {'targetShield': targetShield},    });  }  void useShieldTriggerCard({    required String? gameId,    required int playerId,    required int? currentTurnPlayerId,    required String action,    required bool usingShieldTrigger,    String? triggeredGameCardId,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'currentTurnPlayerId': currentTurnPlayerId,      'action': action,      'usingShieldTrigger': usingShieldTrigger,      'triggeredGameCardId': triggeredGameCardId,    });  }  void doNotUseShieldTriggerCard({    required String? gameId,    required int playerId,    required int? currentTurnPlayerId,    required String action,    required bool usingShieldTrigger,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'currentTurnPlayerId': currentTurnPlayerId,      'action': action,      'usingShieldTrigger': usingShieldTrigger,    });  }  void confirmBlockerSelection({    required String? gameId,    required int playerId,    required int? currentTurnPlayerId,    required String action,    required String attackerId,    required String targetId,    required bool targetShield,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'currentTurnPlayerId': currentTurnPlayerId,      'action': action,      'attackerId': attackerId,      'targetId': targetId,      'targetShield': targetShield,      'hasSelectedBlocker': true,    });  }  void confirmNoBlocker({    required String? gameId,    required int playerId,    required int? currentTurnPlayerId,    required String action,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'currentTurnPlayerId': currentTurnPlayerId,      'action': action,      'hasSelectedBlocker': false,    });  }  void sendDrawCardsFromDeck({    required String? gameId,    required int playerId,    required int? currentTurnPlayerId,    required String action,    required List<String> cardsChosen,    required bool shieldTriggerDecisionMade,    required bool usingShieldTrigger,  }) {    sendMessage({      'gameId': gameId,      'playerId': playerId,      'currentTurnPlayerId': currentTurnPlayerId,      'action': action,      'shieldTriggersFlagsDto': {        'cardsChosen': cardsChosen,        'shieldTriggerDecisionMade': shieldTriggerDecisionMade,      },      'usingShieldTrigger': usingShieldTrigger,    });  }}